\documentclass{article}
\usepackage[a4paper, left=15mm, top=20mm, right=15mm,bottom=20mm]{geometry}
\usepackage{amsmath, amssymb, amsfonts}
\usepackage{fancyhdr}
\usepackage{graphicx}
\graphicspath{ {./images/} }
\usepackage{float}
\usepackage{hyperref}
\usepackage{lscape}

\pagestyle{fancy}
\fancyhf{}
\lhead{CS2040}
\rhead{claudeonrs}
\rfoot{\thepage}
\usepackage{amsmath, amssymb, amsfonts, listings}
\usepackage{xcolor}
\usepackage{enumitem}
\setlist[itemize]{noitemsep, topsep=0pt}
\setlist[enumerate]{noitemsep, topsep=0pt}
\setlist[description]{noitemsep, topsep=0pt}


%New colors defined below
\definecolor{codegreen}{rgb}{0,0.6,0.4}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}
\definecolor{commentgreen}{rgb}{0.4,0.8,0.6}
%Code listing style named "mystyle"
\lstdefinestyle{mystyle}{
  backgroundcolor=\color{backcolour},
  commentstyle=\color{red},
  keywordstyle=\color{blue},
  numberstyle=\tiny\color{codegray},
  stringstyle=\color{codegreen},
  basicstyle=\ttfamily,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  keepspaces=true,
  numbers=left,
  numbersep=5pt,
  showspaces=false,
  showstringspaces=false,
  showtabs=false,
  tabsize=2
}

%"mystyle" code listing set
\lstset{style=mystyle}

\title{No Title}
\author{Claudeon R Susanto}
\date{}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{lmodern}

\renewcommand{\familydefault}{\sfdefault}   % Supprime le serif (dyslexie)
\usepackage[font=sf, labelfont={sf}]{caption}
\usepackage{multicol}
\usepackage{makecell}
\renewcommand\theadalign{bc}
\renewcommand\theadfont{\bfseries}
\renewcommand\theadgape{\Gape[4pt]}
\renewcommand\cellgape{\Gape[4pt]}



% own commands
\newcommand{\eg}[0]{\textit{e.g. }}
\newcommand{\ie}[0]{\textit{i.e. }}
\newcommand{\impt}[0]{\textcolor{red}{\textbf{[IMPT] }}}


\renewcommand\thesubsection{\thesection.\arabic{subsection}}
\setlength{\columnseprule}{1pt}
\begin{document}
%\maketitle
\fontfamily{lmss}\selectfont
\begin{multicols}{2}
\section{Introduction}
\textbf{Some questions to ask before starting on a problem}
\begin{itemize}
	\item Extract out important keywords (what DS to use?)
	\item Edge cases? \eg if \texttt{size==0} or \texttt{size==1},
	\item Trivial cases? can just hardcode
\end{itemize}
\textbf{Code styling}
\begin{itemize}
	\item \href{https://nus-cs2030.github.io/1718-s2/style/index.html}{CS2030 Code Styling Guide}
	\item \href{https://google.github.io/styleguide/javaguide.html}{Google Java Styling Guide}
	\item \textbf{Modularity}: use method to print answers inside main method
	\begin{lstlisting}[language=java]
	\\ print answer
	ans = simulate(n,k,m);
	printAns();	\end{lstlisting}
    \item \textbf{No global variables}
\end{itemize}
\section{Java}

How to throw exception?
\begin{lstlisting}[language=Java]
public class MyException extends Exception {
	private int var;
	public MyException(int var) {
		this.var = var
	}
	public int getVar() {
		return this.var;
	}
}

public class Main {
	public static void main(String[] args) {
		try {
			...
			throw new MyException(errorVar);
		} catch (MyException e) {
			System.out.println(e.getVar());
		}
	}
}\end{lstlisting}




\section{Data Structures}
$$O(1) < O(\log{(n)}) < O(n^c) \text{ where } c<1 $$
$$O(n) <  O(\log{(n!)}) = O(n\log{(n)}) < O(n^2)$$
$$O(n^k)[\text{ where } k>2] < O(k^n) [\text{ where } k\geq1] < O(n!) $$
\textbf{How to implement Data Structures?}
\begin{itemize}
	\item Composition: use well-known DS as an attribute of the implemented DS
	\item Inheritance: extends well-known DS
\end{itemize}
\subsection{Linked List}
\begin{itemize}
	\item Motivation: implementation of list using array needs to occupy contiguous memory space (can result in memory error)
	\item Variants of linked list:
	\begin{itemize}
		\item Tailed (need to maintain \texttt{head} and \texttt{tail})
		\item Circular
		\item Doubly linked (\texttt{prev} and \texttt{next} attributes for \texttt{ListNode})
	\end{itemize}
	\item How to find cycle?\\
	Answer: use fast and slow pointers
	\begin{lstlisting}[language=java]
		slow = slow.next;
		fast = fast.next.next;\end{lstlisting}
	\item \impt Drawing pictures is very important to visualize the program!
\end{itemize}

\textbf{Java API}: \texttt{ArrayList} or \texttt{LinkedList}
\begin{lstlisting}[language=Java]
	\\ constructor
	ArrayList<Integer> list = new ArrayList<Integer>();
\end{lstlisting}

\subsection{Stack}
\begin{lstlisting}[language=Java]
	// to construct an array of generics
	E[] arr = (E[]) new Object[size];
	/*
	// does not work
	E[] arr = new E[size]
	*/
\end{lstlisting}
\textbf{Uses}:
\begin{itemize}
	\item \impt Converting infix to postfix expression (Lecture 4 Slide 28)
	\item \impt Evaluating postfix expression
\end{itemize}

\subsection{Queue}

\textbf{Uses}:
\begin{itemize}
	\item \impt Breadth-first traversal of trees
	\item Sliding Window (especially important for contiguous blocks of stuff)
\end{itemize}
\section{Recursion}
\impt \textbf{Recipe for recursion} (3 fingers)
\begin{enumerate}
	\item \underline{General recursive case}: identify simpler instances of the same problem
	\item \underline{Base case}: cases that we can solve without recursion
	\item Be sure that we are able to \underline{reach the simplest} instance so that we won't end up in infinite loop
\end{enumerate}
\textbf{Uses}
\begin{itemize}
	\item Insert item into sorted LinkedList
	\item Tower of Hanoi
	\item \impt Combination ($n$ choose $k$)
	\item Binary search
	\item Finding $k$-th smalles element (use pivot element \texttt{p})\\
	move elements \texttt{< p} to the left of \texttt{p}\\
	move elements \texttt{> p} to the right of \texttt{p}
	\item Printing all permutations of a String
\end{itemize}
\textbf{Overloading}: same function name but with different parameters (useful in Java)\\
\textbf{Backtracking}
\begin{itemize}
	\item Solving problems recursively by trying to build a solution incrementally, one piece at a time, removing those solutions that fail to satisfy the constraints of the problem at any point in time
	\item \eg Queens Lab 4B: board is fixed\\
	queens can be added or removed!
\end{itemize}
\section{Sorting}
Some definitions
\begin{itemize}
	\item \textbf{Sort key}: use particular value of an object to do comparison and sort
	\item \textbf{In-place}: requires only a constant amount of extra space during the sorting process
	\item \textbf{Stable}: relative order of elements with the same key value is preserved by the algorithm
\end{itemize}
\textbf{Some ideas used in sorting}:
\begin{itemize}
	\item Internal vs external sort
	\item Iterative vs recursive
	\item \underline{Comparison vs non-comparison based}\\
	\eg radix sort
	\item \underline{Divide and conquer}
\end{itemize}
\textbf{Applications}
\begin{itemize}
	\item Uniqueness testing
	\item Deleting duplicates
	\item Frequency counting
	\item Efficient searching
\end{itemize}
\begin{table}[H]
	\centering{
	\begin{tabular}{c|c|c}
		&
		Iterative &
		Recursive \\ \hline
		Comparison &
		\begin{tabular}[c]{@{}c@{}}Bubble,\\ Selection,\\ Insertion\end{tabular} &
		\begin{tabular}[c]{@{}c@{}}Quick,\\ Merge\end{tabular} \\ \hline
		\begin{tabular}[c]{@{}c@{}}Non-\\ comparison\end{tabular} &
		&
		Radix
	\end{tabular}
}
\end{table}
\subsection{Algorithms}
\subsubsection{Selection Sort}
Time complexity: $O(n^2)$\\
Limitation: Not stable
\subsubsection{Bubble Sort}
Time complexity: $O(n^2)$
\begin{itemize}
	\item Using flag: $O(n)$ \texttt{isSorted}, is the input already sorted?
\end{itemize}
\subsubsection{Insertion Sort}
Time complexity:
\begin{itemize}
	\item Best case: input already sorted ($O(n)$)
	\item Worst case: input reversely sorted ($O(n^2)$)
\end{itemize}
\subsubsection{Merge Sort}
Time complexity:
\begin{itemize}
	\item \texttt{merge(arr, left, mid, right)} is $O(right-left+1)$
	\item \texttt{merge} is called $\log{n}$ times
	\item Hence $O(n\log{n})$
\end{itemize}
Limitations:
\begin{itemize}
	\item Need temporary array to store values during the \texttt{merge} process (not in-place)
\end{itemize}
\subsubsection{Quick Sort}
Time complexity:
\begin{itemize}
	\item \texttt{partition()}
	\item \texttt{quicksort(a, i, p)}
	\item Worst case is when it is already sorted, so the first group (elements < p) is empty: $O(n^2)$
	\item Best case: occurs when array is divided into 2 equal halves
	\begin{itemize}
		\item Depth is $\log{n}$
		\item Each level takes $n$ comparisons (including swaps)
		\item Hence $O(n\log{n})$ which is also the average case
	\end{itemize}
\end{itemize}
Limitation: Not stable
\subsubsection{Radix Sort}
Treat each data as a character string: no comparison needed\\
\textbf{Trick}: sort by unit digit $\rightarrow$ tenth digit $\rightarrow$ hundredth and so on...\\
Time complexity:
\begin{itemize}
	\item Initialize 10 groups (queues) to group the elements
	\item Complexity is $O(dn)$ where $d$ is the maximum number of digits of the $n$ numeric strings in the array
\end{itemize}
Limitation: Not in-place

\subsubsection{Bucket Sort}
\textbf{How it works}:
\begin{itemize}
	\item There are $b$ buckets, and each element \texttt{arr} is inserted into bucket according to a function \eg \texttt{(int) arr[j]*10}
	\item Similar to radix sort but $b$ can be any number (base?)\\
	\eg Tut 5 Q 3(b) where $N \leq \texttt{arr[i]} \leq 3N$,  we can have $3N$ buckets $1,2,3, \dots, 3N$ so that each bucket contains only 1 element
	\item So only 1 pass is needed a.k.a. $O(3N)$ time
	\item Possible problem: takes up alot of space?
\end{itemize}
\begin{table}[H]
	\centering{
		\resizebox{\columnwidth}{!}{
			\begin{tabular}{c|c|c|c|c}
				& Worst Case     & Best Case      & In-place? & Stable? \\ \hline
				Selection                                               & $O(n^2)$       & $O(n^2)$       &           & No      \\ \hline
				Insertion                                               & $O(n^2)$       & $O(n)$         &           &         \\ \hline
				Bubble                                                  & $O(n^2)$       & $O(n^2)$       &           &         \\ \hline
				\begin{tabular}[c]{@{}c@{}}Bubble\\ (Flag)\end{tabular} & $O(n^2)$       & $O(n)$         &           &         \\ \hline
				Merge                                                   & $O(n \log{n})$ & $O(n \log{n})$ & No        &         \\ \hline
				Radix                                                   & $O(dn)$        & $O(dn)$        & No        &         \\ \hline
				Quick                                                   & $O(n^2)$       & $O(n \log{n})$ &           & No
			\end{tabular}
	}}
\end{table}

\subsection{Java Sorting}
For list/arrays:
\begin{itemize}
	\item To convert arrays to list use \texttt{Arrays.asList}
	\item \texttt{Arrays.sort} or \texttt{Collections.sort}
\end{itemize}
For others: use \texttt{Collections.sort(list, compObj)}
\begin{lstlisting}[language=Java]
import java.util.Comparator;
class ObjComparator implements Comparator<Obj> {
	public int compare(Obj o1, Obj o2) {
		// if positive, o1 > o2
		// if negative, o1 < o2
		// if zero,     o1 = o2
	}
    public boolean equals(Object obj) {
    	// check to see if we have the same comparator object
    	return this = obj;
    }
}\end{lstlisting}





\section{Java Tricks}
\begin{itemize}
	\item OOP is important (CardGame)
	\begin{itemize}
		\item If it involves an array, OOP is useful, methods can just modify properties/attributes of the object class (\eg \texttt{reversed=true; increment=4})
		\begin{itemize}
			\item Especially true if only need to print statement at the end
		\end{itemize}
	\end{itemize}
	\item Invariance: property that stays constant???\\
	Lab 5C: Pancakes: Use number of inversions if it's even or not
	\item Use \texttt{StringBuilder} for return statements
	\begin{itemize}
		\item \href{https://docs.oracle.com/javase/7/docs/api/java/lang/StringBuilder.html}{Java StringBuilder API}
		\item \href{https://leetcode.com/problems/zigzag-conversion/solution/}{Zigzag conversion}
	\end{itemize}

\end{itemize}
\end{multicols}






\end{document}